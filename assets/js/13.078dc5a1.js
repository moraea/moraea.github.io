(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{412:function(e,t,s){"use strict";s.r(t);var o=s(56),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"debugging-tips"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#debugging-tips"}},[e._v("#")]),e._v(" Debugging Tips")]),e._v(" "),s("p",[e._v("WIP, intended as a list of resources and strategies that are useful when developing non-Metal fixes. Basically the non-metal class you guys always bother me about. Aiming to make this beginner-level without being condescending, please provide feedback...")]),e._v(" "),s("p",[e._v("TODO: bug Slav, Flag, and everyone else who actually knows stuff!")]),e._v(" "),s("h2",{attrs:{id:"assembly-resources"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#assembly-resources"}},[e._v("#")]),e._v(" Assembly Resources")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("cheatsheet 1"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/cirosantilli/x86-assembly-cheat",target:"_blank",rel:"noopener noreferrer"}},[e._v("cheatsheet 2"),s("OutboundLink")],1)])]),e._v(" "),s("p",[e._v("TODO: there are a lot more")]),e._v(" "),s("h2",{attrs:{id:"tools"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tools"}},[e._v("#")]),e._v(" Tools")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://hopperapp.com",target:"_blank",rel:"noopener noreferrer"}},[e._v("Hopper"),s("OutboundLink")],1),e._v(" (easiest, best for objc, 30min demo, no cracks for recent version)")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://hex-rays.com/ida-free/",target:"_blank",rel:"noopener noreferrer"}},[e._v("IDA"),s("OutboundLink")],1),e._v(" (best pseudocode, limited free version, cracks available)")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://ghidra-sre.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ghidra"),s("OutboundLink")],1),e._v(" (scary)")]),e._v(" "),s("li",[s("code",[e._v("objdump")]),e._v(" (built-in, great for scripting (e.g. find all uses of "),s("code",[e._v("PE_parse_boot_argn")]),e._v(" in the system), pass "),s("code",[e._v("--x86-asm-syntax=intel")]),e._v(" for familiar assembly syntax)")]),e._v(" "),s("li",[s("code",[e._v("otool")]),e._v(" (similar to "),s("code",[e._v("objdump")]),e._v(", better at finding string refs and such, but only supports AT&T syntax)")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/nygard/class-dump",target:"_blank",rel:"noopener noreferrer"}},[e._v("class-dump"),s("OutboundLink")],1)]),e._v(" "),s("li",[e._v("TODO: look into Jonathan Levin's stuff")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/Tyilo/insert_dylib",target:"_blank",rel:"noopener noreferrer"}},[e._v("Insert_dylib"),s("OutboundLink")],1)])]),e._v(" "),s("p",[e._v("TODO: more")]),e._v(" "),s("h2",{attrs:{id:"hopper-tips"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hopper-tips"}},[e._v("#")]),e._v(" Hopper Tips")]),e._v(" "),s("ul",[s("li",[e._v("press "),s("code",[e._v("X")]),e._v(" on a function/string for references")]),e._v(" "),s("li",[s("code",[e._v("D")]),e._v(" cycles through 1/2/4/8-byte chunks, various (see Modify) to set data type")]),e._v(" "),s("li",[s("code",[e._v("C")]),e._v(" sets as code, "),s("code",[e._v("P")]),e._v(" creates procedure (needed for pseudocode)")]),e._v(" "),s("li",[e._v("use the Edit menu to copy hex bytes (for some reason cmd+C doesn't work)")])]),e._v(" "),s("p",[e._v("TODO: more tips?\nTODO: hopper scripts/extensions?\nTODO: IDA and stuff")]),e._v(" "),s("h2",{attrs:{id:"calling-convention-just-a-summary-see-cheatsheets"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#calling-convention-just-a-summary-see-cheatsheets"}},[e._v("#")]),e._v(" Calling Convention (just a summary, see cheatsheets)")]),e._v(" "),s("p",[e._v("Function calls use a standard register order, normally:\n"),s("code",[e._v("rdi")]),e._v(", "),s("code",[e._v("rsi")]),e._v(", "),s("code",[e._v("rdx")]),e._v(", "),s("code",[e._v("rcx")]),e._v(", "),s("code",[e._v("r8")]),e._v(", "),s("code",[e._v("r9")])]),e._v(" "),s("p",[e._v("Or the shorter versions:\n"),s("code",[e._v("edi")]),e._v(", "),s("code",[e._v("esi")]),e._v(", "),s("code",[e._v("edx")]),e._v(", "),s("code",[e._v("ecx")]),e._v(", "),s("code",[e._v("r8d")]),e._v(", "),s("code",[e._v("r9d")])]),e._v(" "),s("p",[e._v("Float/double values are passed in "),s("code",[e._v("xmm<number>")]),e._v(" registers. Note that this means it often "),s("em",[e._v("doesn't actually matter")]),e._v(" the order of float values relative to int/pointer ones. "),s("code",[e._v("f(int a,float b)")]),e._v(" and "),s("code",[e._v("f(float a,int b)")]),e._v(" will both use "),s("code",[e._v("edi")]),e._v(" and "),s("code",[e._v("xmm0")]),e._v(".")]),e._v(" "),s("p",[e._v("Structs (a common example being "),s("code",[e._v("CGRect")]),e._v(") get put onto the stack, as do ints/pointers that don't fit into the registers. This can be pretty confusing.")]),e._v(" "),s("p",[e._v("Pointers and pointer types like "),s("code",[e._v("id")]),e._v(" or "),s("code",[e._v("CF...Ref")]),e._v(" are going to "),s("em",[e._v("always")]),e._v(" be 64-bit ("),s("code",[e._v("r...")]),e._v(") registers. Long integers too. Shorter integers (and booleans) will use 32-bit ("),s("code",[e._v("e...")]),e._v(", "),s("code",[e._v("...d")]),e._v("). This can be helpful for guessing types. When writing a shim function, it's usually safe to use "),s("code",[e._v("long")]),e._v(" or "),s("code",[e._v("void*")]),e._v(" for a 64-bit register no matter the value.")]),e._v(" "),s("p",[e._v("Return values will be in "),s("code",[e._v("rax")]),e._v(" unless they're structs (stack), floats ("),s("code",[e._v("xmm0")]),e._v(") or some weird thing that returns two values (TODO).")]),e._v(" "),s("p",[e._v('Keep in mind that C programming also uses a lot of "output parameters", i.e. pointers to a caller-created output variable, passed in as an argument, which the function will dereference and write to.')]),e._v(" "),s("p",[e._v("It's usually easier to figure out a function signature by finding somewhere it's called, rather than its actual implementation. Keep in mind that disassembler pseudocode will often tack on extra arguments (e.g. if something set "),s("code",[e._v("rdx")]),e._v(" a couple lines above, it might think it's the third argument to a 2-argument function), and it will often completely miss floats and stack arguments. If something messes with the stack or sets "),s("code",[e._v("xmm0")]),e._v(" just before a function call, be careful...")]),e._v(" "),s("p",[e._v("In C++ functions, "),s("code",[e._v("this")]),e._v(" is passed in "),s("code",[e._v("rdi")]),e._v(" so the arguments you see in the source code start at "),s("code",[e._v("rsi")]),e._v(".")]),e._v(" "),s("p",[e._v("In objc functions, "),s("code",[e._v("self")]),e._v(" and the selector are passed in "),s("code",[e._v("rdi")]),e._v(" and "),s("code",[e._v("rsi")]),e._v(". However objc signatures can usually be found with type encodings or class-dump anyways (TODO).")]),e._v(" "),s("p",[e._v("TODO: would it be helpful to have a sample walkthrough of finding the signature of some random SL function here?")]),e._v(" "),s("h2",{attrs:{id:"nop-something"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nop-something"}},[e._v("#")]),e._v(" NOP Something")]),e._v(" "),s("p",[e._v("Find the offending assembly and check the hex view or addresses to figure out the file offset and how many bytes to kill (instructions are variable size, so a line of assembly will be multiple "),s("code",[e._v("nop")]),e._v("s). Then use a hex editor or "),s("code",[e._v("Binpatcher")]),e._v(" or whatever to overwrite that range with "),s("code",[e._v("0x90")]),e._v(". Alternately, assemble a jump instruction (alt+A and "),s("code",[e._v("jmp <offset>")]),e._v(") to skip a big chunk of code.")]),e._v(" "),s("p",[e._v("TODO: screenshots if this is confusing")]),e._v(" "),s("h2",{attrs:{id:"patch-something"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#patch-something"}},[e._v("#")]),e._v(" Patch Something")]),e._v(" "),s("p",[e._v("Similarly to "),s("code",[e._v("nop")]),e._v(", but use alt+A to overwrite with lines of assembly and overwrite those corresponding hex bytes instead of "),s("code",[e._v("0x90")]),e._v(". Have to be clever about instruction sizes -- differing sizes will trash (multiple) subsequent lines, make sure to clean up with "),s("code",[e._v("nop")]),e._v("s or use the same size. (Operating on smaller parts of the register (e.g. "),s("code",[e._v("al")]),e._v("/"),s("code",[e._v("eax")]),e._v(" for "),s("code",[e._v("rax")]),e._v(") is usually shorter.)")]),e._v(" "),s("p",[e._v("To force a function to return a certain value, use "),s("code",[e._v("mov rax,<stuff>")]),e._v(" followed by "),s("code",[e._v("ret")]),e._v(". If not at the top of the function, you have to worry about stack stuff (TODO).")]),e._v(" "),s("p",[e._v("TODO: more screenshots")]),e._v(" "),s("h2",{attrs:{id:"dyld-cache"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dyld-cache"}},[e._v("#")]),e._v(" DYLD Cache")]),e._v(" "),s("ul",[s("li",[e._v("check the ramdisk for uncached binaries! (low-ish level, not AppKit or anything sadly)")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://twitter.com/zhuowei/status/1402137181502722051",target:"_blank",rel:"noopener noreferrer"}},[e._v("Apple's extractor"),s("OutboundLink")],1),e._v(" (this will give very broken binaries, but it's great for dumping them all to a folder so you can "),s("code",[e._v("grep")]),e._v(" for mystery error strings)")]),e._v(" "),s("li",[e._v("Hopper and IDA can both load semi-broken binaries")]),e._v(" "),s("li",[e._v("Catalina can be helpful as a last resort")]),e._v(" "),s("li",[e._v("TODO: correlating symbols from lldb/backtrace with sub_... crap in disassemblers")]),e._v(" "),s("li",[e._v("no known (to me) way to get out "),s("em",[e._v("working")]),e._v(" binaries, please prove me wrong...")])]),e._v(" "),s("p",[e._v("TODO: research more tools, Flag sent some?")]),e._v(" "),s("h2",{attrs:{id:"objc-ivars"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#objc-ivars"}},[e._v("#")]),e._v(" OBJC iVars")]),e._v(" "),s("p",[e._v("Sometimes (in Hopper, IDA doesn't seem to handle this) you will see named ivar structures with a small numeric value being added to an id reference. This is the internal implementation of @property.")]),e._v(" "),s("p",[e._v('TODO: definitely needs some screenshots. should also just cover the "struct pointer + offset" concept in general.')]),e._v(" "),s("h2",{attrs:{id:"misc-macos-resources"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#misc-macos-resources"}},[e._v("#")]),e._v(" Misc. macOS Resources")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://osstatus.com",target:"_blank",rel:"noopener noreferrer"}},[e._v("OSStatus"),s("OutboundLink")],1),e._v(" (look up macOS error codes)")]),e._v(" "),s("li",[s("a",{attrs:{href:"http://fuckingblocksyntax.com",target:"_blank",rel:"noopener noreferrer"}},[e._v("fuckingblocksyntax.com"),s("OutboundLink")],1)]),e._v(" "),s("li",[e._v("Jonathan Levin's books (extremely detailed, PDFs on libgen)")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://cdn.discordapp.com/attachments/750933997927792650/860813736116617246/the_textbook.zip",target:"_blank",rel:"noopener noreferrer"}},[e._v("COMP2401 Memory Management PDF"),s("OutboundLink")],1)]),e._v(" "),s("li",[e._v("TODO: that kernel programming book Flag sent")])]),e._v(" "),s("p",[e._v("TODO: there are so many more")]),e._v(" "),s("h2",{attrs:{id:"lldb-tips"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lldb-tips"}},[e._v("#")]),e._v(" LLDB Tips")]),e._v(" "),s("ul",[s("li",[e._v("run "),s("code",[e._v("attach -w -n <process name>")]),e._v(" "),s("em",[e._v("before")]),e._v(" launching the victim process and it will attach and pause when it barely started at all")]),e._v(" "),s("li",[s("code",[e._v("b <function/selector name/address>")]),e._v(" to set a breakpoint")]),e._v(" "),s("li",[s("code",[e._v("b -r '<regex>'")]),e._v(" for setting multiple breakpoints at once, can be very powerful e.g. "),s("code",[e._v("b -r '.*NSWindow.*' -C bt -G true")]),e._v(" to log all NSWindow calls without stopping")]),e._v(" "),s("li",[s("code",[e._v("d")]),e._v(" to print assembly of current function, "),s("code",[e._v("n")]),e._v(" to step without going into calls, "),s("code",[e._v("s")]),e._v(" to step going into calls, "),s("code",[e._v("c")]),e._v(" to resume")]),e._v(" "),s("li",[s("code",[e._v("settings set target.x86-disassembly-flavor intel")]),e._v(" for familiar assembly syntax (can put in "),s("code",[e._v("~/.lldbinit")]),e._v(")")])]),e._v(" "),s("p",[e._v("TODO: example?")]),e._v(" "),s("h2",{attrs:{id:"objc-swizzling"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#objc-swizzling"}},[e._v("#")]),e._v(" ObjC Swizzling")]),e._v(" "),s("ul",[s("li",[e._v("see "),s("code",[e._v("Utils/Swizzle.m")]),e._v(" in the Monterey repo for how to swizzle using an IMP (C-style function) and "),s("a",{attrs:{href:"https://github.com/moraea/slplugins/blob/main/DiskReveal/DiskReveal.m",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),s("OutboundLink")],1),e._v(" for an example implementation.")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://nshipster.com/method-swizzling/",target:"_blank",rel:"noopener noreferrer"}},[e._v("alternate"),s("OutboundLink")],1),e._v(" (and worse, IMO) approach")])]),e._v(" "),s("h2",{attrs:{id:"dyld-interposing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dyld-interposing"}},[e._v("#")]),e._v(" DYLD Interposing")]),e._v(" "),s("ul",[s("li",[e._v("pretty straightforward but you have to paste in that weird macro, TODO")])]),e._v(" "),s("p",[e._v('Note that swizzling/interposing is not only good for "fixing" stuff, but also for dynamic analysis -- logging and experimenting with changing values. I do this a lot.')]),e._v(" "),s("p",[e._v("TODO: "),s("code",[e._v("DYLD_INSERT_LIBRARIES")]),e._v(" (including launchctl and __XPC use, AMFI problems etc)")]),e._v(" "),s("h2",{attrs:{id:"console-log-dmesg"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#console-log-dmesg"}},[e._v("#")]),e._v(" Console/"),s("code",[e._v("log")]),e._v("/"),s("code",[e._v("dmesg")])]),e._v(" "),s("p",[e._v("Not to be underestimated. Make sure to enable debug/info messages. "),s("code",[e._v("log show -last boot -debug -info --predicate 'message contains \"some shit\"'")]),e._v(" is very useful.")]),e._v(" "),s("h2",{attrs:{id:"sample"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sample"}},[e._v("#")]),e._v(" "),s("code",[e._v("sample")])]),e._v(" "),s("p",[e._v("Either run on the command-line or through Activity Monitor, this lists a graph of functions being called in a process. Really great for finding places to start looking in a disassembler and/or seeing if a process is actually doing anything.")]),e._v(" "),s("p",[e._v("TODO: lsof/fs_usage")]),e._v(" "),s("p",[e._v("TODO: so much more to put here...")]),e._v(" "),s("p",[e._v("TODO: would a complete sample workflow of creating a shim function (something simple like the dock ones or accessibility zoom) be useful?")]),e._v(" "),s("p",[e._v("TODO: learn about mach_msg/MIG and document it here (currently all i really know is SLS... corresponding to _X... which is SL specific). similarly, IOConnect... calls. and other XPC stuff")])])}),[],!1,null,null,null);t.default=a.exports}}]);